<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>微服务概览与治理 | 六巷七号</title>
<meta name="description" content="傻逼样的去坚持，自会看见牛逼的结果">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://asdcu.github.io/favicon.ico?v=1670337054372">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://asdcu.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://asdcu.github.io">
        <img src="https://asdcu.github.io/images/avatar.png?v=1670337054372" class="site-logo">
        <h1 class="site-title">六巷七号</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="github.com/asdcu" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
          <a class="social-link" href="https://twitter.com/asd26986328" target="_blank">
            <i class="fab fa-twitter"></i>
          </a>
        
      
        
          <a class="social-link" href="https://weibo.com/u/2067638185" target="_blank">
            <i class="fab fa-weibo"></i>
          </a>
        
      
        
      
        
      
    </div>
    <div class="site-description">
      傻逼样的去坚持，自会看见牛逼的结果
    </div>
    <div class="site-footer">
       | <a class="rss" href="https://asdcu.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">微服务概览与治理</h2>
            <div class="post-date">2021-01-23</div>
            
            <div class="post-content">
              <h3 id="单体架构">单体架构</h3>
<p>尽管也是模块化思维，但是最终还是会打包并部署为单体应用。其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能搞懂它。应用无法拓展，可靠性低，最终敏捷开发和部署变得无法完成。对应的思路就是<strong>换繁为简，分而治之</strong></p>
<h3 id="微服务起源">微服务起源</h3>
<p>大家经常谈论的是一个叫SOA（面向服务）的架构模式。可以把微服务想成SOA的一种实践。</p>
<ul>
<li>小即是美：小的服务代码少、bug也少，易测试，易维护，也更加容易不断迭代完善的精致进而完美</li>
<li>单一职责：一个服务也只需要做好一件事，专注才能做好</li>
<li>尽可能早地创建原型：尽可能早的提供服务API，建立服务契约，达成服务间沟通的一致性约定，至于实现和完善可以慢慢再做。（以前）</li>
<li>可移植行比效率更重要：服务间的轻量级交互协议在效率和可移植性二者间，首要依然考虑兼容性和可移植性</li>
</ul>
<p>上下游关系呈100倍的放大，上游for 100次请求下游，可能下游就是for 10000次的交互</p>
<h3 id="微服务定义">微服务定义</h3>
<p>围绕业务功能构建的，服务关注单一业务，服务间采取轻量级通讯机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活。</p>
<ul>
<li>原子服务</li>
<li>独立进程</li>
<li>隔离部署</li>
<li>去中心化服务治理</li>
</ul>
<p>缺点：</p>
<ul>
<li>基础设施的建设，复杂度高</li>
</ul>
<p>凡是有利弊</p>
<ul>
<li>微服务应用是分布式系统，由此带来固有的复杂性。开发者不得不使用rpc或者消息传递，来实现进程间通信。此外，必须写代码来处理消息传递中速度过慢或者服务不可用等局部失效的问题</li>
<li>分区的数据库架构，同时更新多个业务主体的业务很普遍。这种事务对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同数据库，从而对开发者提出了更高的要求和挑战</li>
<li>测试一个基于微服务架构的应用也是很复杂的任务</li>
<li>服务模块件的依赖，应用的升级很有可能会波及多个模块的修改</li>
<li>对运维基础设施的挑战比较大</li>
</ul>
<p>组件服务化</p>
<p>传统实现组件的方式是通过库library。库是和应用一起打包运行在进程中，库的局部变化以为这整个应用的重新部署。通过服务来实现组件，意味着将应用拆分为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需要重新部署对应的服务进程。用Go实施一个微服务：</p>
<ul>
<li>kit: 一个微服务的基础库（框架）</li>
<li>service：业务代码 + kit依赖 + 第三方依赖组成的业务微服务</li>
<li>rpc + message queue：轻量级通讯</li>
</ul>
<p>本质上等同于多个微服务组合（compose）完成一个完整的用户场景（useracse）</p>
<p>去中心化</p>
<p>每个服务面临的业务场景是不同，可以针对性选择合适的技术解决方案。但也需要避免过度多样化。</p>
<ul>
<li>数据去中心化</li>
<li>治理去中心化</li>
<li>技术去中心化</li>
</ul>
<p>每个服务独享自身的数据存储设施（缓存、数据库等），不想传统应用共享一个缓存和数据库，这样有利于服务的独立性，隔离相关干扰。</p>
<p>基础设施自动化</p>
<p>无自动化不为服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。</p>
<ul>
<li>CICD：Gitlab + Gitlab Hooks + k8s</li>
<li>Testing：测试环境、单元测试、API自动测试（YAPI）</li>
<li>在线运行时：k8s，以及一些列Prometheus，ELK，Control Panle</li>
</ul>
<p>可用性 &amp; 兼容性设计</p>
<p>Design For Failure的思想。所依赖的东西都会炸，防御编程。微服务架构采用粗粒度的进程间通信，引入额外的复杂性和需要处理的新问题。如网络延迟、消息格式、负载均衡和容错，忽略其中任何一点都属于对分布式计算的误解</p>
<ul>
<li>隔离</li>
<li>超时控制</li>
<li>负载保护</li>
<li>限流</li>
<li>降级</li>
<li>重试</li>
<li>负载均衡</li>
</ul>
<p>一旦采用微服务架构模式，那么在服务需要交互时，需要特别小心，服务提供者的变更可能引发消费者兼容性破坏，时刻谨记保持服务契约（接口）的兼容性。</p>
<p>发送时要保守，接受要开放。发送的数据要更加保守，意味着最小化的传送必要信息，接收是更开放意味着要最大限度的容忍冗余数据，保证兼容性。</p>
<p>API Gateway</p>
<p>按照SOA服务化的架构演进，按照垂直功能进行拆分，对外暴露一批微服务，但因缺乏统一的出口，面临不少困难：</p>
<ul>
<li>客户端到微服务直接通信，强耦合</li>
<li>需要多次请求，客户端聚合数据，工作量大，延迟高</li>
<li>协议不利于统一，各个部门间有差异，需要客户端来兼容</li>
<li>面向端的API适配,耦合到内部服务</li>
<li>多端兼容逻辑复杂</li>
</ul>
<p>ref: <a href="https://mp.weixin.qq.com/s/XTzRr0eR6ybpNFGJ57cVkA">https://mp.weixin.qq.com/s/XTzRr0eR6ybpNFGJ57cVkA</a></p>
<p>新增一个app-interface用于统一协议的出口，在服务内进行大量的dataset join，按照业务场景来设计粗粒度的API，给后续服务的演进带来很多优势：</p>
<ul>
<li>轻量级交互：协议精简、聚合</li>
<li>差异服务：数据拆减以及聚合，针对终端定制化API</li>
<li>动态升级：原有系统兼容升级，更新服务而非更新协议</li>
<li>沟通效率提升，协作模式演进为移动业务+网关小组</li>
</ul>
<p>BFF 可以认为是一种适配服务，将后端的微服务进行适配（主要包括聚合裁剪和格式适配等逻辑），向无线端设备暴露友好和统一的API，方便无线设备接入访问后端服务。</p>
<p>不过这种单一app-interface属于一个single point of ailure，严重代码缺陷或者流量洪峰可能会引发集群宕机。</p>
<ul>
<li>单个模块也会导致后续业务继承复杂度高，根据康威法则，单块的无线BFF和多团队之间就出现不匹配的问题，团队之间沟通协调成本高，交付效率低</li>
<li>很多跨横切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间推移，代码变得越来越复杂，技术债越来越多</li>
</ul>
<p>横跨切换（Cross-Cutting Concerns）的功能，需要协调更新框架升级发版（路由、认证、限流、安全），因此全部代码上沉，引入API Gateway，把业务集成度搞的BFF层和通用功能服务层API Gateway进行了分层处理。</p>
<p>这种架构中，网关承担了重要的角色，它是解耦拆分和后续升级的利器。在网关的配合下，单块BFF实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率提升。</p>
<p>另外，把横切面逻辑从BFF层玻璃到网关上去以后，BFF的开发人员可以更加专注业务逻辑得交付，实现架构上的关注分离（Separation Of Concerns）。<br>
外部流量 -&gt; API Gateway -&gt; BFF -&gt; Microservice。</p>
<h3 id="微服务拆分">微服务拆分</h3>
<p>DDD 或者 Business Capability</p>
<ul>
<li>
<p>Business Capability<br>
根据不同各部门提供不同部门</p>
</li>
<li>
<p>Bounded Context<br>
界限上下文是DDD中用来划分不同业务边界的元素。这里的业务边界的含义是&quot;解决不同业务问题&quot;的问题领域和对应的解决方案，为了解决某种类型的业务问题，贴近领域知识，也就是业务。</p>
<p>CORS模式。 将应用程序分为两部分：命令端和查询端。命令端负责程序创建，更新和删除请求，并且在数据更改时发出事件。查询端通过针对一个或者多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的时间流而保持最新。</p>
<p>Polling publisher -&gt; Transaction log tailing</p>
<h3 id="微服务安全">微服务安全</h3>
<p>对于外网的请求，通常在API Gateway进行统一的认证拦截，一旦认证成功，会使用JWT方式通过RPC元数据传递的方式传递到BFF层，BFF层校验Token完整性后把身份信息注入到应用的Context中，BFF层到其他下层的微服务，建议是直接在RPC Request中带入用户身份信息（UserId)请求服务。</p>
<ul>
<li>API Gateway -&gt; BFF -&gt; Service</li>
<li>Biz Auth -&gt; JWT -&gt; Request Args</li>
</ul>
</li>
</ul>
<p>对于服务内部，一般要区分身份认证和身份授权</p>
<ul>
<li>Full Trust</li>
<li>Half Trust</li>
<li>Zero Trust</li>
</ul>
<h3 id="服务发现">服务发现</h3>
<p>目前主要两种方式，第一种以SDK的方式入侵业务代码中，第二种以进程外（sidercar）代理。其中第一种方法已经有很多成熟的方案，如Dubbo；而第二种即为当前火爆的Service Mesh，如Lstio。</p>
<p>首先需要解决服务间通信功能。或者说是服务与服务代理以及代理间的通信。那么代理该如何拦截被代理人接受请求与发出请求。通过iptable，然后再代理应用程序中对相关请求进行处理。</p>
<p>其次服务间通信时，必须知道对方IP和Port，一种方式是直接在本地配死，显而易见，这种方式基本能满足需求，但是却很不方便。目前比较成熟的方案是去配置中心获取。调用第三方接口，获取IP和Port（其实也不是每次都去获取）。另外一种即在本地缓存第三方配置，然后当变更时，实时同步，ZooKeeper。</p>
<h5 id="客户端发现">客户端发现</h5>
<p>一个服务实例被启动时候，它的网络地址会被写到注册表上；当服务实例终止时，再从注册表中删除；这个服务实例的注册表通过心跳机制动态刷新；客户端使用一个负载均衡算法，去选择可用的服务实例，来相应这个请求。</p>
<figure data-type="image" tabindex="1"><img src="https://asdcu.github.io/post-images/1611846124505.png" alt="" loading="lazy"></figure>
<h5 id="服务端发现">服务端发现</h5>
<p>客户端通过负载均衡器向一个服务发送请求，这个负载均衡器会查询服务注册表，并将请求路由到可用的服务实例上。通过客户端的服务发现，服务实例在服务注册表上被注册与注销<br>
（Consul Template + Nginx, kubernetes + etcd）</p>
<figure data-type="image" tabindex="2"><img src="https://asdcu.github.io/post-images/1611846467665.png" alt="" loading="lazy"></figure>
<h5 id="二者比较">二者比较</h5>
<ul>
<li>客户端发现：直连，比服务端少一次网络跳转，Consumer需要内置特定服务发现客户端和发现逻辑</li>
<li>服务端发现：Consumer无需关注服务发现具体细节，只需知道服务的DNS域名即可，支持异构语言开发，需要基础设施支撑，多一次网络跳转，可能有性能损失。</li>
</ul>
<p>微服务的核心是去中心化，使用客户端发现木事!<br>
<img src="https://asdcu.github.io/post-images/1611846864863.png" alt="" loading="lazy"></p>
<p>Zookeeper作为服务发现，但是实际场景的AP系统，是适合海量服务发现和注册</p>
<ul>
<li>分布式协调服务（要求要和时刻对Zookeeper的访问请求得到一致的数据，从而牺牲可用性）</li>
<li>网络抖动或者网络分区导致master节点因为其他主节点失去联系而重新选举或者超过半数不可用导致服务注册发现瘫痪</li>
<li>大量长链接导致性能瓶颈</li>
</ul>
<p>参考Eureka实现API服务发现</p>
<ul>
<li>注册时间延迟</li>
<li>注销时间延迟</li>
</ul>
<p>牺牲一致性，最终一致性的情况</p>
<ul>
<li>
<p>Family（appid）和Addr(Ip:port)定位实例，除此以外还可以附加更多的元数据：权重、染色标签、集群等</p>
</li>
<li>
<p>Provider注册后定期（30s）心跳一次，注册心跳，下线都需要进行同步，注册和下线需要进行长轮训推送</p>
<ul>
<li>新启动节点需要load cache，JVM预热</li>
<li>故障时，Provider不建议重启和发布</li>
</ul>
</li>
<li>
<p>Consumer启动时候拉取实例，发起30秒长轮训</p>
<ul>
<li>故障时候需要client清cache信息</li>
</ul>
</li>
<li>
<p>Server定期（60s）检测失效（90s）的实例，失效则提出。段时间丢失了大量心跳链接（15分钟内心跳低于期望值*85%），开启自我保护，保留过期服务不删除</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://asdcu.github.io/post-images/1611847469430.png" alt="" loading="lazy"></figure>
<h4 id="健康检查">健康检查</h4>
<figure data-type="image" tabindex="4"><img src="https://asdcu.github.io/post-images/1611845720162.png" alt="" loading="lazy"></figure>
<p>主动健康检查health check，可以在服务提供者不稳定时候，被消费者感知，临时从负载均衡中摘除，减少错误请求。当服务提供者重新稳定后，health check 成功，重新加入到消费者的负载均衡，恢复请求。</p>
<p>health check，同样被用于外挂方式的容器健康检查或者流量检测（k8s liveness &amp; readiness）</p>

            </div>
            
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
